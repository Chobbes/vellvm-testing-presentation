\documentclass{beamer}

\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}

\usepackage{preamble}

\usepackage[backend=bibtex]{biblatex}
\addbibresource{citations.bib}

% http://tex.stackexchange.com/questions/68080/beamer-bibliography-icon
\setbeamertemplate{bibliography item}{%
  \ifboolexpr{ test {\ifentrytype{book}} or test {\ifentrytype{mvbook}}
    or test {\ifentrytype{collection}} or test {\ifentrytype{mvcollection}}
    or test {\ifentrytype{reference}} or test {\ifentrytype{mvreference}} }
    {\setbeamertemplate{bibliography item}[book]}
    {\ifentrytype{online}
       {\setbeamertemplate{bibliography item}[online]}
       {\setbeamertemplate{bibliography item}[article]}}%
  \usebeamertemplate{bibliography item}}

\defbibenvironment{bibliography}
  {\list{}
     {\settowidth{\labelwidth}{\usebeamertemplate{bibliography item}}%
      \setlength{\leftmargin}{\labelwidth}%
      \setlength{\labelsep}{\biblabelsep}%
      \addtolength{\leftmargin}{\labelsep}%
      \setlength{\itemsep}{\bibitemsep}%
      \setlength{\parsep}{\bibparsep}}}
  {\endlist}
  {\item}

% Colours for beamer.
\setbeamercolor{frametitle}{fg=orange}
\setbeamertemplate{itemize item}{\color{orange}$\blacksquare$}
\setbeamertemplate{itemize subitem}{\color{orange}$\blacktriangleright$}

% Colours for syntax highlighting
\definecolor{syntax_red}{rgb}{0.7, 0.0, 0.0} % For strings
\definecolor{syntax_green}{rgb}{0.15, 0.5, 0.25} % For comments
\definecolor{syntax_orange}{rgb}{0.7, 0.4, 0.2} % For keywords


% Haskell settings for lstlisting
\lstset{language=Haskell,
basicstyle=\ttfamily\tiny,
keywordstyle=\color{syntax_orange}\bfseries,
stringstyle=\color{syntax_red},
commentstyle=\color{syntax_green},
numbers=none,
numberstyle=\color{black},
stepnumber=1,
frame=single,
breaklines=true,
numbersep=10pt,
tabsize=4,
showspaces=false,
showstringspaces=false}

\author{
  Beck, Calvin\\
  \href{mailto:hobbes@seas.upenn.edu}{hobbes@seas.upenn.edu}
  \and\\~\\
  Zakowski, Yannick\\
  \href{mailto:zakowski@seas.upenn.edu}{zakowski@seas.upenn.edu}
}

\begin{document}

\begin{frame}
  \frametitle{QuickChecking LLVM}
  \maketitle
\end{frame}

\section{Introduction}

\begin{frame}

  Our goal is to use properties based testing to test Vellvm.

  This talk will be structured roughly as follows:
  
  \begin{itemize}
  \item Brief overview of the Vellvm project
  \item Quick Review of QuickCheck / QuickChick
  \item Quick discussion about testing compilers
  \item C Smith
  \item Testing Vellvm using QuickChick generators inspired by C Smith
  \end{itemize}

  Feel free to ask questions. I'm not sure I can have the chat up at
  the same time, so please feel free to {\bf shout}.
\end{frame}

\begin{frame}
  What is Vellvm?

  \begin{itemize}
  \item Formal semantics for LLVM in Coq
    \begin{itemize}
    \item LLVM is an intermediate representation (IR) used by many
      compilers.
    \item Kind of a mix of an assembly language and C.
      % TODO: Insert an example of LLVM code here?
    \end{itemize}
  \item An interpreter for LLVM
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{What does Vellvm hope to do?}

  \begin{itemize}
  \item Some goals:
    \begin{itemize}
    \item Accurately reflect the ``real'' LLVM
    \item Be useful for constructing verified optimization passes
    \item Maybe have a backend in the long term to be a part of
      verified compilation chains.
    \end{itemize}

    We want to answer this question:
    Could properties based testing help with these goals in Vellvm?
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{A Quick(Check) Refresher}

  What is properties based testing? (PBT)

  \begin{itemize}
  \item ``What QuickCheck does''
  \item Basic idea is to test properties of your program using
    automatically generated data.
    \begin{itemize}
    \item Nicely separates the property you care about from specific
      test data.
    \end{itemize}
  \item A property is something like:
    \begin{itemize}
    \item {\tt is\_sorted (sort l)}
    \item {\tt lookup k (insert k v m) == v}
    \end{itemize}
    % ``the sort function produces
    % sorted lists'' or ``if I insert an element $v$ at key $k$ in a
    % map, I'll get back $v$ if I look up $k$''.
  \item Must generate ``test data'' to fill in variables ({\tt l}, {\tt k}, {\tt v}, {\tt m}):
    \begin{itemize}
    \item Enumerate all possible test data
    \item Randomly generate test data
    \item You can mutate a suite of test data~\cite{10.1145/3360607}
    \item Some mix of the above
    \end{itemize}
  \end{itemize}
  
  \pause
  
  Our focus is mostly on random testing---it's shockingly effective,
  though we do anticipate mixing in enumeration in order to get
  backtracking will be effective for handling complex constraints.
  % TODO: does this belong here or does it just seem irrelevant.
\end{frame}

\begin{frame}
  \frametitle{Example of QuickChick}

  % Example of a generator + maybe running QuickChick

\end{frame}

\begin{frame}
  \frametitle{Why PBT in a Theorem Prover?}

  Why not just prove things?

  \begin{itemize}
  \item Proving is hard.
    \pause
  \item Proving false things is even harder.
  \end{itemize}

  QuickChick can really help you work out the kinks in your
  implementation \emph{AND} specification before trying to prove something.
\end{frame}

\begin{frame}
  \frametitle{Why test compilers?}

  % TODO: Not sure that this slide adds much. maybe cut it.
  All software should be tested, but there's good reason for compilers
  to be well tested.

  \begin{itemize}
  \item compilers are complex, with many components
          \begin{itemize}
          \item parsers, lexers, frontends, backends, middlends, oh my.
          \item lots of things that have to work correctly together.
          \end{itemize}
  \item foundational --- nearly all software depends on one in some
    way or another.
    \begin{itemize}
    \item Getting the compiler wrong means any program that was
      influenced by this compiler could be wrong too.
    \end{itemize}
  \end{itemize}
\end{frame}

% \begin{frame}
%   What to test with compilers

%   % TODO: this slide may not survive. was initially mentioned the
%   % components of compilers (front end, middle end, back end), and that
%   % each of these might involve different testing methods + that we're
%   % not really focusing on testing parsers or anything.
%   %
%   % Though, ultimately we're testing with respect to llc's full chain
%   % of compilation.
  
% \end{frame}

\begin{frame}
  \frametitle{}
  % TODO: I don't really like this slide.
  % Should be motivating PBT of compilers. Want to get to the point of
  % "it would be really nice to randomly generate programs, can we do
  % that? C Smith has found success doing this, maybe we can apply
  % what it does to LLVM, here's how C smith works, here's our rough
  % structure for generating LLVM so far (not as fancy yet).
  %
  % I think I have changed the structure enough that I am okay with
  % this slide now.

  Lots of ways to test a compiler:

  \begin{itemize}
  \item Unit test various functions
  \item Manually write down test programs, building up a huge library
    of tests.
  \item Write down an end-to-end proof of correctness
    \begin{itemize}
    \item CompCert
    \end{itemize}
    % TODO: make sure to link this to QuickCheck
  \end{itemize}

  How you test may depend on the component(s) of the compiler being
  tested.

  % TODO:
  % Different things may be easier to do with different parts of the
  % compiler. For instance if the compiler has an internal
  % representation for an intermediate language, this might be harder
  % to test just by building up a sample collection of programs.

  \pause
\end{frame}

\begin{frame}
  \frametitle{Is there a better way?}

  All of these are useful... But...
  
  \begin{itemize}
  \item Manual unit tests, and suites of test programs can be really
    helpful for testing specific behaviours, but can be really tedious
    to create.
    \begin{itemize}
    \item End up testing with a limited number of cases
    \end{itemize}
  \item Proofs are obviously very hard to write
    \begin{itemize}
    \item Plus you can only write a proof if your compiler is correct
      to begin with... % TODO: make sure this is connected with QuickChick.
    \end{itemize}
  \end{itemize}

  Might be nice to automatically generate test cases and run them?

\end{frame}

\begin{frame}

  Generating programs seems hard.

  \begin{itemize}
  \item Lots of constraints
    \begin{itemize}
    \item Need appropriate syntax (if generating syntax)
    \item Needs to typecheck
    \item Needs to be a program
    \end{itemize}
  \item There are many complex, undecidable constraints...
    \begin{itemize}
    \item You might want programs to terminate
    \item Memory safety
    \item Avoid undefined behaviours
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  Furthermore knowing what a program is seems hard...

  \begin{itemize}
  \item Many undefined behaviours in languages like C
  \item Language is ill specified
    \begin{itemize}
    \item Semantics most likely informal, if specified at all
    \item Hard to know *what* to test
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}

  Despite all of these issues tools like C smith seem to do a really
  good job.

  \begin{itemize}
  \item C smith is a tool for testing C compilers by randomly
    generating C programs.
  \item These C programs are run through different C compilers, and
    the results are compared.
  \end{itemize}

  C smith has found hundreds of defects in real world C compilers.
\end{frame}

\begin{frame}
  What does C smith do, and how can we adapt that to test Vellvm?

  \begin{itemize}
  \item Production rules based on the grammar of the programming
    language
  \item Each production is chosen based on a specific probability
  \item C Smith filters out choices that are invalid in the current
    context...
    \begin{itemize}
    \item Continue / break can only appear in a loop, etc.
    \end{itemize}
  \item 
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Termination and C Smith}

  C Smith just uses timeouts in its test harness.

  \begin{itemize}
  \item I'm a little unclear whether it just discards timeouts, or
    actually uses the results.
  \item Always safe to discard, anyway.
  \end{itemize}

  Some of these concerns are likely mitigated by generating idiomatic
  loops, such as loops iterating over array elements, making
  termination much more likely.
\end{frame}
\begin{frame}
  Ultimately we want to test Vellvm.
\end{frame}

\begin{frame}
  Why QuickChick in Coq? Why not just prove things?

  \begin{itemize}
  \item Specifications are hard. How do you know you're spec is
    correct?
    \begin{itemize}
    \item Theorems are hard to state
    \end{itemize}
  \item Proofs are hard.
  \end{itemize}

  QuickChick, in a verification setting, is arguably not used to
  ensure the correctness of the program. It's there to ease
  development.
\end{frame}

\begin{frame}
  Why QuickChick in Vellvm?

  \begin{itemize}
  \item What do we want to test?
  \item Is this just for us, or is it also for users?
  \item Current idea is to do differential testing with clang just to
    see if we differ.
  \item Ultimately we want to test this with 
  \end{itemize}
\end{frame}

\begin{frame}
  So QuickChecking Vellvm seems like a good idea, which means we have
  to generate programs. Why might that be hard?
\end{frame}

\begin{frame}
  Current approach. Very limited.

  \begin{itemize}
  \item What are we testing?
  \item
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Shrinking}

  C Smith mentions the use of delta-debugging in order to produce
  legible bug reports. However, in the paper it's mentioned that this
  approach can lead to undefined behaviour in C, and so they rely upon
  compiler warnings and static analysis to deal with this.

  Shrinking in QuickChick if done naively could lead to similar
  problems with LLVM. A trivial example is shrinking a denominator in
  a division to 0.

  Vellvm in principle should be able to report if an undefined
  behaviour occurs during execution, which 
\end{frame}

\begin{frame}
  \frametitle{Questions?}

\end{frame}

\begin{frame}
  \frametitle{References}

  \nocite{*}
  \printbibliography
\end{frame}

\end{document}
